<!DOCTYPE html>
<html>
<head>
	<title></title>
	
	<style>
		body, html {
			position: relative;
			margin: 0;
			padding: 0;
			height: 100%;
			overflow: hidden;
		}
		
		#wrapper {
			position: relative;
			margin: 0 auto;
			box-sizing: border-box;
			border: 1px solid #eee;
		}
	</style>
</head>
<body>
	<div id="wrapper"></div>
	
	<script>
		function createTetris(parentElement) {
			var frame = document.createElement('iframe')
			with(frame.style) {
				position = 'absolute'
				width = '100%'
				height = '100%'
				border = 'none'
			}
			
			parentElement.appendChild(frame)
			
			
			var canvas = document.createElement('canvas')
			var canvasContext = canvas.getContext('2d')
			
			
			var pixelWidth
			var pixelHeight
			var pointWidth
			var pointHeight
			
			function updateSize() {
				pixelWidth = parentElement.clientWidth
				pixelHeight = parentElement.clientHeight
				
				pointWidth = parentElement.clientWidth / 10
				pointHeight = parentElement.clientHeight / 20
				
				canvas.setAttribute('width', pixelWidth)
				canvas.setAttribute('height', pixelHeight)
			}
			
			updateSize()
			
			
			function clear() {
				canvasContext.fillStyle = '#222222'
				canvasContext.fillRect(0, 0, pixelWidth, pixelHeight)
			}
			
			function drawPoint(x, y, color) {
				canvasContext.fillStyle = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')'
				canvasContext.fillRect(x * pointWidth , y * pointHeight, pointWidth, pointHeight)
				
				canvasContext.fillStyle = 'rgb(' + color[0] * 2 + ',' + color[1] * 2 + ',' + color[2] * 2 + ')'
				canvasContext.fillRect(x * pointWidth + 1 , y * pointHeight + 1, pointWidth - 2, pointHeight - 2)
				
				canvasContext.fillStyle = 'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')'
				canvasContext.fillRect(x * pointWidth + 2 , y * pointHeight + 2, pointWidth - 4, pointHeight - 4)
			}
			
			function normalizeFigure(figure) {
				function hasLeftSpace() {
					for(var y = 0; y < 4; ++y) {
						if(figure[y * 4]) {
							return false
						}
					}
					
					return true
				}
				
				function hasTopSpace() {
					for(var x = 0; x < 4; ++x) {
						if(figure[x]) {
							return false
						}
					}
					
					return true
				}
				
				while(hasLeftSpace()) {
					//shift left
					for(var y = 0; y < 4; ++y) {
						for(var x = 1; x < 4; ++x) {
							figure[y * 4 + x - 1] = figure[y * 4 + x]
						}
					}
					
					for(var y = 0; y < 4; ++y) {
						figure[y * 4 + 3] = null
					}
				}
				
				while(hasTopSpace()) {
					//shift top
					for(var y = 1; y < 4; ++y) {
						for(var x = 0; x < 4; ++x) {
							figure[(y - 1) * 4 + x] = figure[y * 4 + x]
						}
					}
					
					for(var x = 0; x < 4; ++x) {
						figure[3 * 4 + x] = null
					}
				}
			}
			
			function generateFigure() {
				var figure = new Array(4 * 4).fill(null)
				var color = [Math.random() * 127 + 64, Math.random() * 127 + 64, Math.random() * 127 + 64]
				
				figure[0] = color
				
				for(var i = 0; i < 3; ++i) {
					switch(Math.floor(Math.random() * 4)) {
						case 0: { //top
							//shift down
							for(var y = 3; y; --y) {
								for(var x = 0; x < 4; ++x) {
									figure[y * 4 + x] = figure[(y - 1) * 4 + x]
								}
							}
							
							for(var x = 0; x < 4; ++x) {
								figure[0 * 4 + x] = null
							}
							
							figure[0] = color
							break
						}
						
						case 1: { //right
							//find first zero right pos
							for(var x = 1; figure[0 * 4 + x]; ++x);
							
							figure[0 * 4 + x] = color
							break
						}
						
						case 2: { //bottom
							//find first zero bottom pos
							for(var y = 1; figure[y * 4 + 0]; ++y);
								
							figure[y * 4 + 0] = color
							break
						}
						
						case 3: { //left
							//shift right
							for(var y = 0; y < 4; ++y) {
								for(var x = 3; x; --x) {
									figure[y * 4 + x] = figure[y * 4 + x - 1]
								}
							}
							
							for(var y = 0; y < 4; ++y) {
								figure[y * 4] = null
							}
							
							figure[0] = color
							break
						}
					}
				}
				
				normalizeFigure(figure)
					
				return figure
			}
			
			function drawFigure(figure, offsetX, offsetY) {
				for(var y = 0; y < 4; ++y) {
					for(var x = 0; x < 4; ++x) {
						if(figure[y * 4 + x] && y + offsetY < 20) {
							drawPoint(x + offsetX, y + offsetY, figure[y * 4 + x])
						}
					}
				}
			}
			
			/*
			1000 0000 0010 0000 1100
			1000 0000 1110 1100 0100
			1100 0010 0000 0100 0100
			0000 1110 0000 0100 0000
			
			(0, 0) -> (0, 3)
			(0, 1) -> (1, 3)
			(0, 2) -> (2, 3)
			*/
			
			function rotateFigure(figure) {
				var rotatedFigure = new Array(4 * 4)
				
				for(var y = 0; y < 4; ++y) {
					for(var x = 0; x < 4; ++x) {
						rotatedFigure[(3 - x) * 4 + y] = figure[y * 4 + x]
					}
				}
				
				normalizeFigure(rotatedFigure)
				
				return rotatedFigure
			}
			
			var currentFigure = generateFigure()
			var figureX = 4
			var figureY = 0
			
			
			var level = new Array(20 * 10).fill(null)
			
			function drawLevel(level) {
				for(var y = 0; y < 20; ++y) {
					for(var x = 0; x < 10; ++x) {
						if(level[y * 10 + x]) {
							drawPoint(x, y, level[y * 10 + x])
						}
					}
				}
			}
			
			function normalizeLevel(level) {
				function freeLine(y) {
					for(; y > 0; --y) {
						for(var x = 0; x < 10; ++x) {
							level[y * 10 + x] = level[(y - 1) * 10 + x]
						}
					}
				}
				
				for(var y = 0; y < 20; ++y) {
					var hasFullLine = true
					
					for(var x = 0; x < 10; ++x) {
						if(!level[y * 10 + x]) {
							hasFullLine = false
							break
						}
					}
					
					if(hasFullLine) {
						freeLine(y)
					}
				}
			}
			
			function levelIntersectWithFigure(figure, offsetX, offsetY, level) {
				for(var y = 0; y < 4; ++y) {
					for(var x = 0; x < 4; ++x) {
						if(figure[y * 4 + x] && (x + offsetX >= 10 || y + offsetY >= 20 || level[(y + offsetY) * 10 + x + offsetX])) {
							return true
						}
					}
				}
				
				return false
			}
			
			function fillLevelWithFigure(figure, offsetX, offsetY, level) {
				for(var y = 0; y < 4; ++y) {
					for(var x = 0; x < 4; ++x) {
						if(figure[y * 4 + x] && x + offsetX < 10 && y + offsetY < 20) {
							level[(y + offsetY) * 10 + x + offsetX] = figure[y * 4 + x]
						}
					}
				}
			}
			
			
			function drawAll() {
				clear()
				drawLevel(level)
				drawFigure(currentFigure, figureX, figureY)
			}
			
			drawAll()
			

			var numberOfTicks = 0
			var speed = 8
			var gameIntervalId
			
			frame.contentWindow.onfocus = function() {
				clearInterval(gameIntervalId)
				
				gameIntervalId = setInterval(function() {
					if(!(numberOfTicks % speed)) {
						++figureY
						
						if(levelIntersectWithFigure(currentFigure, figureX, figureY, level)) {
							fillLevelWithFigure(currentFigure, figureX, figureY - 1, level)
							normalizeLevel(level)
							
							currentFigure = generateFigure()
							figureX = 4
							figureY = 0
							
							if(levelIntersectWithFigure(currentFigure, figureX, figureY, level)) {
								drawAll()
								clearInterval(gameIntervalId)
								//frame.contentWindow.alert('game over')
							}
						}
						
						drawAll()
					}
					
					++numberOfTicks
				}, 50)
			}
			
			frame.contentWindow.onblur = function() {
				clearInterval(gameIntervalId)
			}
			
			frame.contentWindow.onresize = function() {
				updateSize()
				drawAll()
			}
			

			frame.contentWindow.onkeydown = function(event) {
				switch(event.keyCode) {
					case 38: { //ArrowUp
						var rotatedFigure = rotateFigure(currentFigure)
						
						if(!levelIntersectWithFigure(rotatedFigure, figureX, figureY, level)) {
							currentFigure = rotatedFigure
						}
						
						drawAll()
						
						break
					}
					
					case 37: { //ArrowLeft
						if(figureX && !levelIntersectWithFigure(currentFigure, figureX - 1, figureY, level)) {
							--figureX
						}
						
						drawAll()
						
						break
					}
					
					case 39: { //ArrowRight
						if(!levelIntersectWithFigure(currentFigure, figureX + 1, figureY, level)) {
							++figureX
						}
						
						drawAll()
						
						break
					}
					
					case 40: { //ArrowDown
						speed = 1
						break
					}
				}
			}
			
			frame.contentWindow.onkeyup = function(event) {
				switch(event.keyCode) {
					case 40: { //ArrowDown
						speed = 8
						break
					}
				}
			}
			
			
			
			parentElement.appendChild(canvas)
			
			return {
				frame: frame
			}
		}
		
		
		function updateWrapperSize() {
			var wrapperWidth
			var wrapperHeight
			
			if(document.body.clientWidth > document.body.clientHeight) {
				wrapperHeight = document.body.clientHeight
				wrapperWidth = wrapperHeight / 2
			}
			else {
				wrapperHeight = document.body.clientWidth
				wrapperWidth = wrapperHeight / 2
			}
			
			with(wrapper.style) {
				width = Math.floor(wrapperWidth) + 'px'
				height = Math.floor(wrapperHeight) + 'px'
			}
		}
		
		updateWrapperSize()
		
		window.onresize = function() {
			console.log('resize')
			updateWrapperSize()
		}
		
		var tetris = createTetris(wrapper)
		tetris.frame.focus()
	</script>
</body>
</html>